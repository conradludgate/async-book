<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The beginners guide of async Rust</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
<script async defer data-website-id="e017be59-bc25-481d-a443-71f725a81b71" src="https://api.conradludgate.com/umami.js"></script>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="ch00/00-introduction.html"><strong aria-hidden="true">1.</strong> Introduction to async</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch00/01-example.html"><strong aria-hidden="true">1.1.</strong> Example of Async</a></li><li class="chapter-item expanded "><a href="ch00/02-runtime.html"><strong aria-hidden="true">1.2.</strong> What is a runtime</a></li><li class="chapter-item expanded "><a href="ch00/03-using-a-runtime.html"><strong aria-hidden="true">1.3.</strong> Using a runtime</a></li></ol></li><li class="chapter-item expanded "><a href="ch01/00-futures.html"><strong aria-hidden="true">2.</strong> Futures</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The beginners guide of async Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction-to-async"><a class="header" href="#introduction-to-async">Introduction to Async</a></h1>
<p>Async code exists to allow a programming language to offer more control
in the way that code can run concurrently.
A famous example of an async programming language is JS,
which can only execute code using 1 thread, but still needs
to support allowing multiple streams of work to happen at the same time.</p>
<p>For instance, say you want to make a network request,
but while you're communicating with the external service, you want
to update the web page with a live updating progress bar.</p>
<p>One way we can accomplish this in a single threaded setup is by allowing multiplexing.
That is, allowing one task to temporarily pause to allow another task to resume.
Eventually, both tasks will be run to completion, but neither will block the other.</p>
<h2 id="threading-vs-async"><a class="header" href="#threading-vs-async">Threading vs Async</a></h2>
<p>I've already hinted at another mechanism to allow concurrency, threads!
Rust allows multithreading, so why do we need async code?
Well, there's many reasons.
Maybe you're writing code on an embedded device that only supports a single threaded operations.
Maybe you're working in the Linux kernel itself and don't have access to just create threads as you please.
Maybe you just want more control about what tasks can run and in which order,
and to not be at the mercy of your OS scheduler.</p>
<p>Whatever your reasoning, async rust should be general enough to support your needs.</p>
<h2 id="concurrency-vs-parallelism"><a class="header" href="#concurrency-vs-parallelism">Concurrency vs Parallelism</a></h2>
<p>Concurrency and Parallelism are different, but related concepts.</p>
<p>Concurrency is the process of performing tasks out-of-order. For example, if you have two tasks,
a simple setup is to perform task 1, then task 2. But if these tasks involve any waiting, then you're wasting time.
Instead, concurrency is the idea that you can do some of task 1 and some of task 2 in any order. Eventually both
will be complete and the same end goal is reached, but in potentially much less time.</p>
<p>Parallelism is the process of performing tasks at the same time. This would involve multiple workers
(CPU cores, services, threads, people etc) performing their single task. Using the example above, tasks 1 &amp; 2 will be started immediately
and will complete as soon as possible, however it might take double the resources in the worst case.</p>
<p>Both concepts have the same goal of reducing the time a combination of tasks may take, but in different ways.
Parallelism requires more resources, but concurrency can't achieve the same throughput levels. </p>
<p>Async Rust provides you with <strong>concurrency</strong>. However, most async runtimes make use of thread pools in order to utilise
a fixed amount of parallelism. In theory, this lets you achieve as much throughput as possible with the least resources available
in your system.</p>
<h2 id="async-rust"><a class="header" href="#async-rust">Async Rust</a></h2>
<p>Under the hood, async-await in Rust is syntax sugar that makes it easy to build cooperative-coroutines, unlike the preemptive green threads
you might see in Go or Java. This means that you must expliclty mark where a task may pause using <code>.await</code>. The runtime isn't able to
pause a task because it's taking a long time. For that reason, you typically have to be careful to not do too much CPU bound work in between
<code>.await</code> lines. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-of-async"><a class="header" href="#example-of-async">Example of Async</a></h1>
<pre><pre class="playground"><code class="language-rust">use axum::{
    routing::get,
    Router,
};

#[tokio::main]
async fn main() {
    // build our application with a single route
    let app = Router::new().route(&quot;/&quot;, get(index));

    axum::Server::bind(&amp;&quot;0.0.0.0:3000&quot;.parse().unwrap())
        .serve(app.into_make_service())
        .await
        .unwrap();
}

async fn index() {
    let client = reqwest::Client::new();
    let res = client.post(&quot;http://example.com/counter&quot;)
        .send()
        .await;

    match res {
        Ok(_) =&gt; &quot;Welcome to my site!&quot;,
        Err(_) =&gt; &quot;Error registering your visit&quot;,
    }
}
</code></pre></pre>
<p>This is a very typical async application,
featuring <a href="https://docs.rs/axum/latest/axum/">axum</a> as the HTTP server library,
<a href="https://docs.rs/reqwest/latest/reqwest/">reqwest</a> as the HTTP client library,
and <a href="https://tokio.rs/">tokio</a> as the async runtime.</p>
<p>The key feature here is that each incomming server request happen 'asynchronously'.
While each request handler is waiting on the response, it yields control
of the thread over to another request that needs to be handled.</p>
<p>Let's break down what that means:</p>
<p>As a request comes in, our server will launch the request handler as a new async 'task'.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Task 1:
    let client = reqwest::Client::new();
    let res = client.post(&quot;http://example.com/counter&quot;)
        .send()
        .await;
        // register interest in sending and receiving data.
        // Our runtime will pause this task

// Task 2:
    let client = reqwest::Client::new();
    let res = client.post(&quot;http://example.com/counter&quot;)
        .send()
        .await;
        // register interest in sending and receiving data.
        // Our runtime will pause this task

// Task 1:
    // our runtime has monitored the OS and found that the data is now ready,
    // resumes task 1.
    match res {
        Ok(_) =&gt; &quot;Welcome to my site!&quot;,
        Err(_) =&gt; &quot;Error registering your visit&quot;,
    }

// Task 2:
    // our runtime has monitored the OS and found that the data is now ready,
    // resumes task 2.
    match res {
        Ok(_) =&gt; &quot;Welcome to my site!&quot;,
        Err(_) =&gt; &quot;Error registering your visit&quot;,
    }
<span class="boring">}
</span></code></pre></pre>
<p>Paired with multiple threads to fully utilise the CPU cores, a good runtime can achieve
hundreds of thousands requests per second, with many many thousands concurrent requests.</p>
<p>Over the course of this book, we will find out how these actually work, from a high level
down to some very low level implementation details</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-a-runtime"><a class="header" href="#what-is-a-runtime">What is a runtime</a></h1>
<p>At a high level, in order to run through your async functions, you need a runtime to manage which tasks are ready,
as well as getting the tasks processed in an efficient way.</p>
<p>The two most popular runtimes at the time of writing are <a href="https://tokio.rs/">tokio</a>, <a href="https://docs.rs/smol/1.2.5/smol/">smol</a>, and <a href="https://async.rs/">async-std</a>.
All three achieve similar end results by utilising work-stealing and IO polling.</p>
<h2 id="anatomy-of-a-runtime"><a class="header" href="#anatomy-of-a-runtime">Anatomy of a runtime</a></h2>
<p>A runtime is collection of worker threads that share some state between them. At it's core, the runtime
will has a shared queue of ready tasks, and possible a shared queue of waiting tasks. The job of the worker
is to progress a task forward, poll the OS to see if any other tasks that were waiting for IO are ready, and countdown any waiting timers.</p>
<p>For efficiency, most runtime workers will have their own local queue of tasks, and employ tactics like work distribution and work stealing in order
to not starve any workers so they can maintain the maximum parallelism and throughput.</p>
<p>Put into some psuedo-rust-code, this worker process might look like</p>
<pre><code class="language-rust ignore">loop {
    // check if anything new is ready
    timers.count_down();
    os.poll();

    // get a task from the local queue
    let mut task = local_queue.pop_front();

    // if our local queue has no tasks, take some from the global queue
    if task.is_none() {
        local_queue.take_from(&amp;mut global_queue);
        task = local_queue.pop_front();
    }

    // if there still isn't a task available, check the other workers
    for worker in &amp;mut workers {
        if task.is_some() { break }

        local_queue.steal_from(worker);
        task = local_queue.pop_front();
    }

    // if there was a task, run it.
    // otherwise, pause this thread.
    if let Some(task) = task {
        task.progress();
    } else {
        pause();
    }
}
</code></pre>
<p>In reality, there's a bit more logic involved to maximise CPU efficiency, but that's the gist of it.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>You might be working on platforms without access to the std library. This means you don't have access to the OS,
or access to threads. In which case, you can simplify that event loop down significantly as you have no global queue
or workers to steal from. You also don't need to worry about OS polling or pausing. </p>
<p>Similarly, you might be using a 'thread-per-core' architecture, which removes the potentially expensive work-stealing step,
but can reduce throughput in some workloads. This also allows you to run tasks that are <code>!Send</code> (can't be sent between threads).
This is the technique employed by <a href="https://docs.rs/actix-rt/2.7.0/actix_rt/">actix-rt</a>
by utilising <a href="https://docs.rs/tokio/1.22.0/tokio/task/struct.LocalSet.html">Tokio's <code>LocalSet</code></a>.
<a href="https://www.datadoghq.com/blog/engineering/introducing-glommio/">Glommio</a> is another such runtime with this feature</p>
<h2 id="choosing-a-runtime"><a class="header" href="#choosing-a-runtime">Choosing a runtime</a></h2>
<p>Unfortunately, while there's a lot of options for runtimes, there's often not a lot of choice you as a user can make.</p>
<p>If you want to use the <code>axum</code>/<code>reqwest</code> libraries as shown in <a href="ch00/./01-example.html">the previous example</a>, you <strong>must</strong> use <code>tokio</code>. This is because
internally these use <code>tokio::spawn</code>, <code>tokio::net</code> and <code>tokio::time</code> modules. All of these must be called in the context of a tokio runtime
and will panic if the thread local runtime global is not set.</p>
<p>Some libraries are generic over runtimes. <code>hyper</code>, the HTTP engine that <code>axum</code> and <code>reqwest</code> are based on, is generic over executors using
traits like <a href="https://docs.rs/hyper/0.14.23/hyper/rt/trait.Executor.html">Executor</a> to abstract away the <code>tokio::spawn</code>, 
and <a href="https://docs.rs/hyper/0.14.23/hyper/server/accept/trait.Accept.html">Accept</a> to abstract away the <code>tokio::net::TcpListener</code>.</p>
<p>Similarly, there exists <a href="https://docs.rs/executor-trait/2.1.0/executor_trait/">executor-trait</a>
and <a href="https://docs.rs/reactor-trait/1.1.0/reactor_trait/index.html">reactor-trait</a> which are used by <a href="https://crates.io/crates/lapin"><code>lapin</code></a>
in order to allow the async runtime to be configured in trait-objects. This requires more allocation overhead but potentially can
speed up compile times if you don't need extreme performance.</p>
<p>Because <code>tokio</code> is orders of magnitudes more popular than <code>smol</code> and <code>async-std</code>, there also exists compatibility layers like
<a href="https://docs.rs/async-compat/latest/async_compat/">async-compat</a> which run tokio-based async code within a tokio context.
This comes with the added cost that any tokio actions are spawned into an extra single threaded runtime, reducing overall resource
efficiency.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-a-runtime"><a class="header" href="#using-a-runtime">Using a runtime</a></h1>
<h2 id="spawning"><a class="header" href="#spawning">Spawning</a></h2>
<p>Spawning a task is analogous to spawning a thread. It creates a new top-level task with no parent for the runtime to process.
This usually returns a <code>JoinHandle</code>, similar again to the threaded version. Awaiting the join handle will pause the current task until the spawned task is
complete.</p>
<pre><code class="language-rust ignore">/// Downloads a set of pages concurrently
async fn download_pages(pages: Vec&lt;String&gt;) -&gt; Vec&lt;(String, Vec&lt;u8&gt;)&gt; {
    let mut work = Vec::with_capacity(pages.len());
    for page in pages {
        // spawn each download job into it's own task.
        // this ensures that all the download tasks are run concurrently
        let handle = tokio::spawn(async {
            let bytes = download_page(&amp;page).await;
            (page, bytes)
        });

        // store the handles
        work.push(handle);
    }

    let mut output = Vec::with_capacity(pages.len());
    for handle in work {
        // join lets us get the output of the task
        output.push(handle.await.unwrap())
    }

    output
}

/// Downloads the page contents at the URL
async fn download_page(url: &amp;str) -&gt; Vec&lt;u8&gt; {
    todo!()
}
</code></pre>
<p>Depending on the runtime, you may also get the ability to 'abort' or 'cancel' a task. This in theory should remove the task from any queues, but it's never
that simple in practice and it usually just sets a flag that this task can be skipped instead.</p>
<p>Given the similar API to thread::spawn, this requires that tasks have a <code>'static</code> lifetime.</p>
<h2 id="network"><a class="header" href="#network">Network</a></h2>
<p>Much like <a href="https://doc.rust-lang.org/std/net/index.html"><code>std::net</code></a>, 
general purpose runtimes expose their own network primitives. 
Also, much like how std has <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a>/<a href="https://doc.rust-lang.org/std/io/trait.Write.html"><code>Write</code></a> traits,
these runtimes will often have a similar <a href="https://docs.rs/smol/1.2.5/smol/prelude/trait.AsyncRead.html"><code>AsyncRead</code></a>/<a href="https://docs.rs/smol/1.2.5/smol/prelude/trait.AsyncWrite.html"><code>Write</code></a> traits</p>
<h2 id="timers"><a class="header" href="#timers">Timers</a></h2>
<p>Finally, most runtimes offer efficient alternatives to <a href="https://doc.rust-lang.org/nightly/std/thread/fn.sleep.html"><code>std::thread::sleep</code></a>. 
This is often extended to provide interval clocks that repeatedly fire, as well as timeouts that can cancel tasks that take too long.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="futures"><a class="header" href="#futures">Futures</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
